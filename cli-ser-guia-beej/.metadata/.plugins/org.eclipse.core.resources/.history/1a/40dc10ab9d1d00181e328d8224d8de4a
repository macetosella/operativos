Go to the previous, next section.

Programming with GNU Readline
This chapter describes the interface between the GNU Readline Library and other programs. If you are a programmer, and you wish to include the features found in GNU Readline such as completion, line editing, and interactive history manipulation in your own programs, this section is for you.

Basic Behavior
Many programs provide a command line interface, such as mail, ftp, and sh. For such programs, the default behaviour of Readline is sufficient. This section describes how to use Readline in the simplest way possible, perhaps to replace calls in your code to gets() or fgets ().

The function readline () prints a prompt and then reads and returns a single line of text from the user. The line readline returns is allocated with malloc (); you should free () the line when you are done with it. The declaration for readline in ANSI C is

char *readline (char *prompt);
So, one might say

char *line = readline ("Enter a line: ");
in order to read a line of text from the user. The line returned has the final newline removed, so only the text remains.
If readline encounters an EOF while reading the line, and the line is empty at that point, then (char *)NULL is returned. Otherwise, the line is ended just as if a newline had been typed.

If you want the user to be able to get at the line later, (with C-p for example), you must call add_history () to save the line away in a history list of such lines.

add_history (line);
For full details on the GNU History Library, see the associated manual.

It is preferable to avoid saving empty lines on the history list, since users rarely have a burning need to reuse a blank line. Here is a function which usefully replaces the standard gets () library function, and has the advantage of no static buffer to overflow:

/* A static variable for holding the line. */
static char *line_read = (char *)NULL;

/* Read a string, and return a pointer to it.  Returns NULL on EOF. */
char *
rl_gets ()
{
  /* If the buffer has already been allocated, return the memory
     to the free pool. */
  if (line_read)
    {
      free (line_read);
      line_read = (char *)NULL;
    }

  /* Get a line from the user. */
  line_read = readline ("");

  /* If the line has any text in it, save it on the history. */
  if (line_read && *line_read)
    add_history (line_read);

  return (line_read);
}
This function gives the user the default behaviour of TAB completion: completion on file names. If you do not want Readline to complete on filenames, you can change the binding of the TAB key with rl_bind_key ().

int rl_bind_key (int key, int (*function)());
rl_bind_key () takes two arguments: key is the character that you want to bind, and function is the address of the function to call when key is pressed. Binding TAB to rl_insert () makes TAB insert itself. rl_bind_key () returns non-zero if key is not a valid ASCII character code (between 0 and 255).

Thus, to disable the default TAB behavior, the following suffices:

rl_bind_key ('\t', rl_insert);
This code should be executed once at the start of your program; you might write a function called initialize_readline () which performs this and other desired initializations, such as installing custom completers (see section Custom Completers).

Custom Functions
Readline provides many functions for manipulating the text of the line, but it isn't possible to anticipate the needs of all programs. This section describes the various functions and variables defined within the Readline library which allow a user program to add customized functionality to Readline.

The Function Type
For readabilty, we declare a new type of object, called Function. A Function is a C function which returns an int. The type declaration for Function is:

typedef int Function ();

The reason for declaring this new type is to make it easier to write code describing pointers to C functions. Let us say we had a variable called func which was a pointer to a function. Instead of the classic C declaration

int (*)()func;

we may write

Function *func;

Similarly, there are

typedef void VFunction ();
typedef char *CPFunction (); and
typedef char **CPPFunction ();
for functions returning no value, pointer to char, and pointer to pointer to char, respectively.

Writing a New Function
In order to write new functions for Readline, you need to know the calling conventions for keyboard-invoked functions, and the names of the variables that describe the current state of the line read so far.

The calling sequence for a command foo looks like

foo (int count, int key)
where count is the numeric argument (or 1 if defaulted) and key is the key that invoked this function.

It is completely up to the function as to what should be done with the numeric argument. Some functions use it as a repeat count, some as a flag, and others to choose alternate behavior (refreshing the current line as opposed to refreshing the screen, for example). Some choose to ignore it. In general, if a function uses the numeric argument as a repeat count, it should be able to do something useful with both negative and positive arguments. At the very least, it should be aware that it can be passed a negative argument.

Variable: char * rl_line_buffer

This is the line gathered so far. You are welcome to modify the contents of the line, but see section Allowing Undoing.

Variable: int rl_point

The offset of the current cursor position in rl_line_buffer (the point).

Variable: int rl_end

The number of characters present in rl_line_buffer. When rl_point is at the end of the line, rl_point and rl_end are equal.

Variable: int rl_mark

The mark (saved position) in the current line. If set, the mark and point define a region.

Variable: int rl_done

Setting this to a non-zero value causes Readline to return the current line immediately.

Variable: int rl_pending_input

Setting this to a value makes it the next keystroke read. This is a way to stuff a single character into the input stream.

Variable: char * rl_prompt

The prompt Readline uses. This is set from the argument to readline (), and should not be assigned to directly.

Variable: char * rl_terminal_name

The terminal type, used for initialization.

Variable: char * rl_readline_name

This variable is set to a unique name by each application using Readline. The value allows conditional parsing of the inputrc file (see section Conditional Init Constructs).

Variable: FILE * rl_instream

The stdio stream from which Readline reads input.

Variable: FILE * rl_outstream

The stdio stream to which Readline performs output.

Variable: Function * rl_startup_hook

If non-zero, this is the address of a function to call just before readline prints the first prompt.

Readline Convenience Functions
Naming a Function
The user can dynamically change the bindings of keys while using Readline. This is done by representing the function with a descriptive name. The user is able to type the descriptive name when referring to the function. Thus, in an init file, one might find

Meta-Rubout:	backward-kill-word
This binds the keystroke Meta-Rubout to the function descriptively named backward-kill-word. You, as the programmer, should bind the functions you write to descriptive names as well. Readline provides a function for doing that:

Function: int rl_add_defun (char *name, Function *function, int key)

Add name to the list of named functions. Make function be the function that gets called. If key is not -1, then bind it to function using rl_bind_key ().

Using this function alone is sufficient for most applications. It is the recommended way to add a few functions to the default functions that Readline has built in. If you need to do something other than adding a function to Readline, you may need to use the underlying functions described below.

Selecting a Keymap
Key bindings take place on a keymap. The keymap is the association between the keys that the user types and the functions that get run. You can make your own keymaps, copy existing keymaps, and tell Readline which keymap to use.

Function: Keymap rl_make_bare_keymap ()

Returns a new, empty keymap. The space for the keymap is allocated with malloc (); you should free () it when you are done.

Function: Keymap rl_copy_keymap (Keymap map)

Return a new keymap which is a copy of map.

Function: Keymap rl_make_keymap ()

Return a new keymap with the printing characters bound to rl_insert, the lowercase Meta characters bound to run their equivalents, and the Meta digits bound to produce numeric arguments.

Function: void rl_discard_keymap (Keymap keymap)

Free the storage associated with keymap.

Readline has several internal keymaps. These functions allow you to change which keymap is active.

Function: Keymap rl_get_keymap ()

Returns the currently active keymap.

Function: void rl_set_keymap (Keymap keymap)

Makes keymap the currently active keymap.

Function: Keymap rl_get_keymap_by_name (char *name)

Return the keymap matching name. name is one which would be supplied in a set keymap inputrc line (see section Readline Init File).

Binding Keys
You associate keys with functions through the keymap. Readline has several internal keymaps: emacs_standard_keymap, emacs_meta_keymap, emacs_ctlx_keymap, vi_movement_keymap, and vi_insertion_keymap. emacs_standard_keymap is the default, and the examples in this manual assume that.

These functions manage key bindings.

Function: int rl_bind_key (int key, Function *function)

Binds key to function in the currently active keymap. Returns non-zero in the case of an invalid key.

Function: int rl_bind_key_in_map (int key, Function *function, Keymap map)

Bind key to function in map. Returns non-zero in the case of an invalid key.

Function: int rl_unbind_key (int key)

Bind key to the null function in the currently active keymap. Returns non-zero in case of error.

Function: int rl_unbind_key_in_map (int key, Keymap map)

Bind key to the null function in map. Returns non-zero in case of error.

Function: int rl_generic_bind (int type, char *keyseq, char *data, Keymap map)

Bind the key sequence represented by the string keyseq to the arbitrary pointer data. type says what kind of data is pointed to by data; this can be a function (ISFUNC), a macro (ISMACR), or a keymap (ISKMAP). This makes new keymaps as necessary. The initial keymap in which to do bindings is map.

Function: int rl_parse_and_bind (char *line)

Parse line as if it had been read from the inputrc file and perform any key bindings and variable assignments found (see section Readline Init File).

Associating Function Names and Bindings
These functions allow you to find out what keys invoke named functions and the functions invoked by a particular key sequence.

Function: Function * rl_named_function (char *name)

Return the function with name name.

Function: Function * rl_function_of_keyseq (char *keyseq, Keymap map, int *type)

Return the function invoked by keyseq in keymap map. If map is NULL, the current keymap is used. If type is not NULL, the type of the object is returned in it (one of ISFUNC, ISKMAP, or ISMACR).

Function: char ** rl_invoking_keyseqs (Function *function)

Return an array of strings representing the key sequences used to invoke function in the current keymap.

Function: char ** rl_invoking_keyseqs_in_map (Function *function, Keymap map)

Return an array of strings representing the key sequences used to invoke function in the keymap map.

Allowing Undoing
Supporting the undo command is a painless thing, and makes your functions much more useful. It is certainly easy to try something if you know you can undo it. I could use an undo function for the stock market.

If your function simply inserts text once, or deletes text once, and uses rl_insert_text () or rl_delete_text () to do it, then undoing is already done for you automatically.

If you do multiple insertions or multiple deletions, or any combination of these operations, you should group them together into one operation. This is done with rl_begin_undo_group () and rl_end_undo_group ().

The types of events that can be undone are:

enum undo_code { UNDO_DELETE, UNDO_INSERT, UNDO_BEGIN, UNDO_END };
Notice that UNDO_DELETE means to insert some text, and UNDO_INSERT means to delete some text. That is, the undo code tells undo what to undo, not how to undo it. UNDO_BEGIN and UNDO_END are tags added by rl_begin_undo_group () and rl_end_undo_group ().

Function: int rl_begin_undo_group ()

Begins saving undo information in a group construct. The undo information usually comes from calls to rl_insert_text () and rl_delete_text (), but could be the result of calls to rl_add_undo ().

Function: int rl_end_undo_group ()

Closes the current undo group started with rl_begin_undo_group (). There should be one call to rl_end_undo_group () for each call to rl_begin_undo_group ().

Function: void rl_add_undo (enum undo_code what, int start, int end, char *text)

Remember how to undo an event (according to what). The affected text runs from start to end, and encompasses text.

Function: void free_undo_list ()

Free the existing undo list.

Function: int rl_do_undo ()

Undo the first thing on the undo list. Returns 0 if there was nothing to undo, non-zero if something was undone.

Finally, if you neither insert nor delete text, but directly modify the existing text (e.g., change its case), call rl_modifying () once, just before you modify the text. You must supply the indices of the text range that you are going to modify.

Function: int rl_modifying (int start, int end)

Tell Readline to save the text between start and end as a single undo unit. It is assumed that you will subsequently modify that text.

Redisplay
Function: int rl_redisplay ()

Change what's displayed on the screen to reflect the current contents of rl_line_buffer.

Function: int rl_forced_update_display ()

Force the line to be updated and redisplayed, whether or not Readline thinks the screen display is correct.

Function: int rl_on_new_line ()

Tell the update routines that we have moved onto a new (empty) line, usually after ouputting a newline.

Function: int rl_reset_line_state ()

Reset the display state to a clean state and redisplay the current line starting on a new line.

Function: int rl_message (va_alist)

The arguments are a string as would be supplied to printf. The resulting string is displayed in the echo area. The echo area is also used to display numeric arguments and search strings.

Function: int rl_clear_message ()

Clear the message in the echo area.

Modifying Text
Function: int rl_insert_text (char *text)

Insert text into the line at the current cursor position.

Function: int rl_delete_text (int start, int end)

Delete the text between start and end in the current line.

Function: char * rl_copy_text (int start, int end)

Return a copy of the text between start and end in the current line.

Function: int rl_kill_text (int start, int end)

Copy the text between start and end in the current line to the kill ring, appending or prepending to the last kill if the last command was a kill command. The text is deleted. If start is less than end, the text is appended, otherwise prepended. If the last command was not a kill, a new kill ring slot is used.

Utility Functions
Function: int rl_reset_terminal (char *terminal_name)

Reinitialize Readline's idea of the terminal settings using terminal_name as the terminal type (e.g., vt100).

Function: int alphabetic (int c)

Return 1 if c is an alphabetic character.

Function: int numeric (int c)

Return 1 if c is a numeric character.

Function: int ding ()

Ring the terminal bell, obeying the setting of bell-style.

The following are implemented as macros, defined in chartypes.h.

Function: int uppercase_p (int c)

Return 1 if c is an uppercase alphabetic character.

Function: int lowercase_p (int c)

Return 1 if c is a lowercase alphabetic character.

Function: int digit_p (int c)

Return 1 if c is a numeric character. Function:

Function: int to_upper (int c)

If c is a lowercase alphabetic character, return the corresponding uppercase character.

Function: int to_lower (int c)

If c is an uppercase alphabetic character, return the corresponding lowercase character.

Function: int digit_value (int c)

If c is a number, return the value it represents.

An Example
Here is a function which changes lowercase characters to their uppercase equivalents, and uppercase characters to lowercase. If this function was bound to `M-c', then typing `M-c' would change the case of the character under point. Typing `M-1 0 M-c' would change the case of the following 10 characters, leaving the cursor on the last character changed.

/* Invert the case of the COUNT following characters. */
int
invert_case_line (count, key)
     int count, key;
{
  register int start, end, i;

  start = rl_point;

  if (rl_point >= rl_end)
    return (0);

  if (count < 0)
    {
      direction = -1;
      count = -count;
    }
  else
    direction = 1;

  /* Find the end of the range to modify. */
  end = start + (count * direction);

  /* Force it to be within range. */
  if (end > rl_end)
    end = rl_end;
  else if (end < 0)
    end = 0;

  if (start == end)
    return (0);

  if (start > end)
    {
      int temp = start;
      start = end;
      end = temp;
    }

  /* Tell readline that we are modifying the line, so it will save
     the undo information. */
  rl_modifying (start, end);

  for (i = start; i != end; i++)
    {
      if (uppercase_p (rl_line_buffer[i]))
        rl_line_buffer[i] = to_lower (rl_line_buffer[i]);
      else if (lowercase_p (rl_line_buffer[i]))
        rl_line_buffer[i] = to_upper (rl_line_buffer[i]);
    }
  /* Move point to on top of the last character changed. */
  rl_point = (direction == 1) ? end - 1 : start;
  return (0);
}
Custom Completers
Typically, a program that reads commands from the user has a way of disambiguating commands and data. If your program is one of these, then it can provide completion for commands, data, or both. The following sections describe how your program and Readline cooperate to provide this service.

How Completing Works
In order to complete some text, the full list of possible completions must be available. That is, it is not possible to accurately expand a partial word without knowing all of the possible words which make sense in that context. The Readline library provides the user interface to completion, and two of the most common completion functions: filename and username. For completing other types of text, you must write your own completion function. This section describes exactly what such functions must do, and provides an example.

There are three major functions used to perform completion:

The user-interface function rl_complete (). This function is called with the same arguments as other Readline functions intended for interactive use: count and invoking_key. It isolates the word to be completed and calls completion_matches () to generate a list of possible completions. It then either lists the possible completions, inserts the possible completions, or actually performs the completion, depending on which behavior is desired.
The internal function completion_matches () uses your generator function to generate the list of possible matches, and then returns the array of these matches. You should place the address of your generator function in rl_completion_entry_function.
The generator function is called repeatedly from completion_matches (), returning a string each time. The arguments to the generator function are text and state. text is the partial word to be completed. state is zero the first time the function is called, allowing the generator to perform any necessary initialization, and a positive non-zero integer for each subsequent call. When the generator function returns (char *)NULL this signals completion_matches () that there are no more possibilities left. Usually the generator function computes the list of possible completions when state is zero, and returns them one at a time on subsequent calls. Each string the generator function returns as a match must be allocated with malloc(); Readline frees the strings when it has finished with them.
Function: int rl_complete (int ignore, int invoking_key)

Complete the word at or before point. You have supplied the function that does the initial simple matching selection algorithm (see completion_matches ()). The default is to do filename completion.

Variable: Function * rl_completion_entry_function

This is a pointer to the generator function for completion_matches (). If the value of rl_completion_entry_function is (Function *)NULL then the default filename generator function, filename_entry_function (), is used.

Completion Functions
Here is the complete list of callable completion functions present in Readline.

Function: int rl_complete_internal (int what_to_do)

Complete the word at or before point. what_to_do says what to do with the completion. A value of `?' means list the possible completions. `TAB' means do standard completion. `*' means insert all of the possible completions. `!' means to display all of the possible completions, if there is more than one, as well as performing partial completion.

Function: int rl_complete (int ignore, int invoking_key)

Complete the word at or before point. You have supplied the function that does the initial simple matching selection algorithm (see completion_matches () and rl_completion_entry_function). The default is to do filename completion. This calls rl_complete_internal () with an argument depending on invoking_key.

Function: int rl_possible_completions (int count, int invoking_key))

List the possible completions. See description of rl_complete (). This calls rl_complete_internal () with an argument of `?'.

Function: int rl_insert_completions (int count, int invoking_key))

Insert the list of possible completions into the line, deleting the partially-completed word. See description of rl_complete (). This calls rl_complete_internal () with an argument of `*'.

Function: char ** completion_matches (char *text, CPFunction *entry_func)

Returns an array of (char *) which is a list of completions for text. If there are no completions, returns (char **)NULL. The first entry in the returned array is the substitution for text. The remaining entries are the possible completions. The array is terminated with a NULL pointer.

entry_func is a function of two args, and returns a (char *). The first argument is text. The second is a state argument; it is zero on the first call, and non-zero on subsequent calls. entry_func returns a NULL pointer to the caller when there are no more matches.

Function: char * filename_completion_function (char *text, int state)

A generator function for filename completion in the general case. Note that completion in Bash is a little different because of all the pathnames that must be followed when looking up completions for a command. The Bash source is a useful reference for writing custom completion functions.

Function: char * username_completion_function (char *text, int state)

A completion generator for usernames. text contains a partial username preceded by a random character (usually `~'). As with all completion generators, state is zero on the first call and non-zero for subsequent calls.

Completion Variables
Variable: Function * rl_completion_entry_function

A pointer to the generator function for completion_matches (). NULL means to use filename_entry_function (), the default filename completer.

Variable: CPPFunction * rl_attempted_completion_function

A pointer to an alternative function to create matches. The function is called with text, start, and end. start and end are indices in rl_line_buffer saying what the boundaries of text are. If this function exists and returns NULL, or if this variable is set to NULL, then rl_complete () will call the value of rl_completion_entry_function to generate matches, otherwise the array of strings returned will be used.

Variable: int rl_completion_query_items

Up to this many items will be displayed in response to a possible-completions call. After that, we ask the user if she is sure she wants to see them all. The default value is 100.

Variable: char * rl_basic_word_break_characters

The basic list of characters that signal a break between words for the completer routine. The default value of this variable is the characters which break words for completion in Bash, i.e., " \t\n\"\\'`@$><=;|&{(".

Variable: char * rl_completer_word_break_characters

The list of characters that signal a break between words for rl_complete_internal (). The default list is the value of rl_basic_word_break_characters.

Variable: char * rl_special_prefixes

The list of characters that are word break characters, but should be left in text when it is passed to the completion function. Programs can use this to help determine what kind of completing to do. For instance, Bash sets this variable to "$@" so that it can complete shell variables and hostnames.

Variable: int rl_ignore_completion_duplicates

If non-zero, then disallow duplicates in the matches. Default is 1.

Variable: int rl_filename_completion_desired

Non-zero means that the results of the matches are to be treated as filenames. This is always zero on entry, and can only be changed within a completion entry generator function. If it is set to a non-zero value, directory names have a slash appended and Readline attempts to quote completed filenames if they contain any embedded word break characters.

Variable: int rl_filename_quoting_desired

Non-zero means that the results of the matches are to be quoted using double quotes (or an application-specific quoting mechanism) if the completed filename contains any characters in rl_completer_word_break_chars. This is always non-zero on entry, and can only be changed within a completion entry generator function.

Variable: Function * rl_ignore_some_completions_function

This function, if defined, is called by the completer when real filename completion is done, after all the matching names have been generated. It is passed a NULL terminated array of matches. The first element (matches[0]) is the maximal substring common to all matches. This function can re-arrange the list of matches as required, but each element deleted from the array must be freed.

Variable: char * rl_completer_quote_characters

List of characters which can be used to quote a substring of the line. Completion occurs on the entire substring, and within the substring rl_completer_word_break_characters are treated as any other character, unless they also appear within this list.

A Short Completion Example
Here is a small application demonstrating the use of the GNU Readline library. It is called fileman, and the source code resides in `examples/fileman.c'. This sample application provides completion of command names, line editing features, and access to the history list.

/* fileman.c -- A tiny application which demonstrates how to use the
   GNU Readline library.  This application interactively allows users
   to manipulate files and their modes. */

#include <stdio.h>
#include <sys/types.h>
#include <sys/file.h>
#include <sys/stat.h>
#include <sys/errno.h>

#include <readline/readline.h>
#include <readline/history.h>

extern char *getwd ();
extern char *xmalloc ();

/* The names of functions that actually do the manipulation. */
int com_list (), com_view (), com_rename (), com_stat (), com_pwd ();
int com_delete (), com_help (), com_cd (), com_quit ();

/* A structure which contains information on the commands this program
   can understand. */

typedef struct {
  char *name;			/* User printable name of the function. */
  Function *func;		/* Function to call to do the job. */
  char *doc;			/* Documentation for this function.  */
} COMMAND;

COMMAND commands[] = {
  { "cd", com_cd, "Change to directory DIR" },
  { "delete", com_delete, "Delete FILE" },
  { "help", com_help, "Display this text" },
  { "?", com_help, "Synonym for `help'" },
  { "list", com_list, "List files in DIR" },
  { "ls", com_list, "Synonym for `list'" },
  { "pwd", com_pwd, "Print the current working directory" },
  { "quit", com_quit, "Quit using Fileman" },
  { "rename", com_rename, "Rename FILE to NEWNAME" },
  { "stat", com_stat, "Print out statistics on FILE" },
  { "view", com_view, "View the contents of FILE" },
  { (char *)NULL, (Function *)NULL, (char *)NULL }
};

/* Forward declarations. */
char *stripwhite ();
COMMAND *find_command ();

/* The name of this program, as taken from argv[0]. */
char *progname;

/* When non-zero, this global means the user is done using this program. */
int done;

char *
dupstr (s)
     int s;
{
  char *r;

  r = xmalloc (strlen (s) + 1);
  strcpy (r, s);
  return (r);
}

main (argc, argv)
     int argc;
     char **argv;
{
  char *line, *s;

  progname = argv[0];

  initialize_readline ();	/* Bind our completer. */

  /* Loop reading and executing lines until the user quits. */
  for ( ; done == 0; )
    {
      line = readline ("FileMan: ");

      if (!line)
        break;

      /* Remove leading and trailing whitespace from the line.
         Then, if there is anything left, add it to the history list
         and execute it. */
      s = stripwhite (line);

      if (*s)
        {
          add_history (s);
          execute_line (s);
        }

      free (line);
    }
  exit (0);
}

/* Execute a command line. */
int
execute_line (line)
     char *line;
{
  register int i;
  COMMAND *command;
  char *word;

  /* Isolate the command word. */
  i = 0;
  while (line[i] && whitespace (line[i]))
    i++;
  word = line + i;

  while (line[i] && !whitespace (line[i]))
    i++;

  if (line[i])
    line[i++] = '\0';

  command = find_command (word);

  if (!command)
    {
      fprintf (stderr, "%s: No such command for FileMan.\n", word);
      return (-1);
    }

  /* Get argument to command, if any. */
  while (whitespace (line[i]))
    i++;

  word = line + i;

  /* Call the function. */
  return ((*(command->func)) (word));
}

/* Look up NAME as the name of a command, and return a pointer to that
   command.  Return a NULL pointer if NAME isn't a command name. */
COMMAND *
find_command (name)
     char *name;
{
  register int i;

  for (i = 0; commands[i].name; i++)
    if (strcmp (name, commands[i].name) == 0)
      return (&commands[i]);

  return ((COMMAND *)NULL);
}

/* Strip whitespace from the start and end of STRING.  Return a pointer
   into STRING. */
char *
stripwhite (string)
     char *string;
{
  register char *s, *t;

  for (s = string; whitespace (*s); s++)
    ;

  if (*s == 0)
    return (s);

  t = s + strlen (s) - 1;
  while (t > s && whitespace (*t))
    t--;
  *++t = '\0';

  return s;
}

/* **************************************************************** */
/*                                                                  */
/*                  Interface to Readline Completion                */
/*                                                                  */
/* **************************************************************** */

char *command_generator ();
char **fileman_completion ();

/* Tell the GNU Readline library how to complete.  We want to try to complete
   on command names if this is the first word in the line, or on filenames
   if not. */
initialize_readline ()
{
  /* Allow conditional parsing of the ~/.inputrc file. */
  rl_readline_name = "FileMan";

  /* Tell the completer that we want a crack first. */
  rl_attempted_completion_function = (CPPFunction *)fileman_completion;
}

/* Attempt to complete on the contents of TEXT.  START and END show the
   region of TEXT that contains the word to complete.  We can use the
   entire line in case we want to do some simple parsing.  Return the
   array of matches, or NULL if there aren't any. */
char **
fileman_completion (text, start, end)
     char *text;
     int start, end;
{
  char **matches;

  matches = (char **)NULL;

  /* If this word is at the start of the line, then it is a command
     to complete.  Otherwise it is the name of a file in the current
     directory. */
  if (start == 0)
    matches = completion_matches (text, command_generator);

  return (matches);
}

/* Generator function for command completion.  STATE lets us know whether
   to start from scratch; without any state (i.e. STATE == 0), then we
   start at the top of the list. */
char *
command_generator (text, state)
     char *text;
     int state;
{
  static int list_index, len;
  char *name;

  /* If this is a new word to complete, initialize now.  This includes
     saving the length of TEXT for efficiency, and initializing the index
     variable to 0. */
  if (!state)
    {
      list_index = 0;
      len = strlen (text);
    }

  /* Return the next name which partially matches from the command list. */
  while (name = commands[list_index].name)
    {
      list_index++;

      if (strncmp (name, text, len) == 0)
        return (dupstr(name));
    }

  /* If no names matched, then return NULL. */
  return ((char *)NULL);
}

/* **************************************************************** */
/*                                                                  */
/*                       FileMan Commands                           */
/*                                                                  */
/* **************************************************************** */

/* String to pass to system ().  This is for the LIST, VIEW and RENAME
   commands. */
static char syscom[1024];

/* List the file(s) named in arg. */
com_list (arg)
     char *arg;
{
  if (!arg)
    arg = "";

  sprintf (syscom, "ls -FClg %s", arg);
  return (system (syscom));
}

com_view (arg)
     char *arg;
{
  if (!valid_argument ("view", arg))
    return 1;

  sprintf (syscom, "more %s", arg);
  return (system (syscom));
}

com_rename (arg)
     char *arg;
{
  too_dangerous ("rename");
  return (1);
}

com_stat (arg)
     char *arg;
{
  struct stat finfo;

  if (!valid_argument ("stat", arg))
    return (1);

  if (stat (arg, &finfo) == -1)
    {
      perror (arg);
      return (1);
    }

  printf ("Statistics for `%s':\n", arg);

  printf ("%s has %d link%s, and is %d byte%s in length.\n", arg,
          finfo.st_nlink,
          (finfo.st_nlink == 1) ? "" : "s",
          finfo.st_size,
          (finfo.st_size == 1) ? "" : "s");
  printf ("Inode Last Change at: %s", ctime (&finfo.st_ctime));
  printf ("      Last access at: %s", ctime (&finfo.st_atime));
  printf ("    Last modified at: %s", ctime (&finfo.st_mtime));
  return (0);
}

com_delete (arg)
     char *arg;
{
  too_dangerous ("delete");
  return (1);
}

/* Print out help for ARG, or for all of the commands if ARG is
   not present. */
com_help (arg)
     char *arg;
{
  register int i;
  int printed = 0;

  for (i = 0; commands[i].name; i++)
    {
      if (!*arg || (strcmp (arg, commands[i].name) == 0))
        {
          printf ("%s\t\t%s.\n", commands[i].name, commands[i].doc);
          printed++;
        }
    }

  if (!printed)
    {
      printf ("No commands match `%s'.  Possibilties are:\n", arg);

      for (i = 0; commands[i].name; i++)
        {
          /* Print in six columns. */
          if (printed == 6)
            {
              printed = 0;
              printf ("\n");
            }

          printf ("%s\t", commands[i].name);
          printed++;
        }

      if (printed)
        printf ("\n");
    }
  return (0);
}

/* Change to the directory ARG. */
com_cd (arg)
     char *arg;
{
  if (chdir (arg) == -1)
    {
      perror (arg);
      return 1;
    }

  com_pwd ("");
  return (0);
}

/* Print out the current working directory. */
com_pwd (ignore)
     char *ignore;
{
  char dir[1024], *s;

  s = getwd (dir);
  if (s == 0)
    {
      printf ("Error getting pwd: %s\n", dir);
      return 1;
    }

  printf ("Current directory is %s\n", dir);
  return 0;
}

/* The user wishes to quit using this program.  Just set DONE non-zero. */
com_quit (arg)
     char *arg;
{
  done = 1;
  return (0);
}

/* Function which tells you that you can't do this. */
too_dangerous (caller)
     char *caller;
{
  fprintf (stderr,
           "%s: Too dangerous for me to distribute.  Write it yourself.\n",
           caller);
}

/* Return non-zero if ARG is a valid argument for CALLER, else print
   an error message and return zero. */
int
valid_argument (caller, arg)
     char *caller, *arg;
{
  if (!arg || !*arg)
    {
      fprintf (stderr, "%s: Argument required.\n", caller);
      return (0);
    }

  return (1);
}
Go to the previous, next section.
